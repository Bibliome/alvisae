<alvisnlp-plan id="alvisae2bionlp-st">
  <param name="db-props">
    <alias module="read" param="databasePropsFile"/>
  </param>
  
  <param name="campaigns">
    <alias module="read" param="campaignId"/>
  </param>
    
  <param name="task">
    <alias module="read" param="taskName"/>
  </param>
    
  <param name="user">
    <alias module="read" param="userNames"/>
  </param>
    
  <param name="docs">
    <alias module="read" param="docIds"/>
  </param>

  <param name="add-layout-newlines">
    <alias module="add-layout-newlines" param="active"/>
  </param>

  <param name="normalizations-file">
    <alias module="normalizations.map" param="mappingFile"/>
    <alias module="normalizations.relation" param="source"/>
  </param>

  <param name="type-exclusion-file">
    <alias module="exclude-types.map" param="mappingFile"/>
  </param>

  <param name="zone-type">
    <alias module="zones.feature" param="value"/>
  </param>

  <param name="zone-selection">
    <alias module="zones.do.trim" param="fragmentSelection"/>
  </param>

  <param name="type-names-file">
    <alias module="type-name.map" param="mappingFile"/>
  </param>

  <param name="out-dir">
    <alias module="write.docs" param="outDir"/>
    <alias module="write.text" param="outDir"/>
    <alias module="write.layout" param="outDir"/>
    <alias module="write.entities" param="outDir"/>
    <alias module="write.normalizations" param="outDir"/>
    <alias module="write.relations" param="outDir"/>
  </param>

  <read class="AlvisAEReader">
    <userFeature>user</userFeature>
    <section>text</section>
    <typeFeature>__TYPE</typeFeature>
    <fragmentTypeFeature>__TYPE</fragmentTypeFeature>
    <campaignIdFeature>campaign-id</campaignIdFeature>
    <campaignNameFeature>campaign-name</campaignNameFeature>
    <userIdFeature>user-id</userIdFeature>
    <taskIdFeature>task-id</taskIdFeature>
    <campaignNameFeature>campaign-name</campaignNameFeature>
  </read>

  <zones>
    <feature class="SetFeature">
      <target>$</target>
      <feature>zone-type</feature>
      <value/>
    </feature>

    <do>
      <active>@zone-type != ""</active>

      <layer class="Action">
	<target>documents.sections.relations[@name == corpus.@zone-type].tuples</target>
	<action>args.add:zone</action>
	<addToLayer/>
      </layer>

      <trim class="MergeSections">
	<documentFilter>int(sections.layer:zone)>0</documentFilter>
	<targetSection>trimmed</targetSection>
	<fragmentLayer>zone</fragmentLayer>
      </trim>
    </do>
  </zones>

  <remove-empty>
    <layout class="Action">
      <target>documents.sections.layer:html[@form =~ "^\\s*$"]</target>
      <action>delete</action>
      <deleteElements/>
    </layout>
    
    <entities class="Action">
      <target>documents.sections.relations[@kind == "text-bound"].tuples[pred:all(args, @form =~ "^\\s*$")]</target>
      <action>
	($|args).delete
      </action>
      <deleteElements/>
    </entities>
  </remove-empty>

  <exclude-types>
    <map class="FileMapper">
      <target>documents.sections.relations</target>
      <form>@name</form>
      <targetFeatures>excluded</targetFeatures>
    </map>

    <delete class="Action">
      <target>documents.sections.relations[@excluded]</target>
      <action>delete</action>
      <deleteElements/>
    </delete>
  </exclude-types>

  <add-layout-newlines class="InsertContents">
    <active>false</active>
    <points>layer:html[(@tag =~ "^h\\d$" or @tag == "p" or @tag == "br") and not ctx:after(1) =~ "^\\s$"]</points>
    <offset>end</offset>
    <insert>"&#xA;"</insert>
  </add-layout-newlines>

  <delete-empty-tuples>
    <pass-1>
      <unset-arg class="Action">
	<target>documents.sections.relations[@kind == "relation" or @kind == "group"].tuples[args[not args]]</target>
	<action>
	  nav:arguments[not args] as a.target.set:remove-arg(a.@role)
	</action>
	<setArguments/>
      </unset-arg>

      <delete class="Action">
	<target>documents.sections.relations.tuples[not args]</target>
	<action>delete</action>
	<deleteElements/>
      </delete>
    </pass-1>

    <pass-2>
      <unset-arg class="Action">
	<target>documents.sections.relations[@kind == "relation" or @kind == "group"].tuples[args[not args]]</target>
	<action>
	  nav:arguments[not args] as a.target.set:remove-arg(a.@role)
	</action>
	<setArguments/>
      </unset-arg>

      <delete class="Action">
	<target>documents.sections.relations.tuples[not args]</target>
	<action>delete</action>
	<deleteElements/>
      </delete>
    </pass-2>

    <pass-3>
      <unset-arg class="Action">
	<target>documents.sections.relations[@kind == "relation" or @kind == "group"].tuples[args[not args]]</target>
	<action>
	  nav:arguments[not args] as a.target.set:remove-arg(a.@role)
	</action>
	<setArguments/>
      </unset-arg>

      <delete class="Action">
	<target>documents.sections.relations.tuples[not args]</target>
	<action>delete</action>
	<deleteElements/>
      </delete>
    </pass-3>

    <pass-4>
      <unset-arg class="Action">
	<target>documents.sections.relations[@kind == "relation" or @kind == "group"].tuples[args[not args]]</target>
	<action>
	  nav:arguments[not args] as a.target.set:remove-arg(a.@role)
	</action>
	<setArguments/>
      </unset-arg>

      <delete class="Action">
	<target>documents.sections.relations.tuples[not args]</target>
	<action>delete</action>
	<deleteElements/>
      </delete>
    </pass-4>

    <pass-5>
      <unset-arg class="Action">
	<target>documents.sections.relations[@kind == "relation" or @kind == "group"].tuples[args[not args]]</target>
	<action>
	  nav:arguments[not args] as a.target.set:remove-arg(a.@role)
	</action>
	<setArguments/>
      </unset-arg>

      <delete class="Action">
	<target>documents.sections.relations.tuples[not args]</target>
	<action>delete</action>
	<deleteElements/>
      </delete>
    </pass-5>
  </delete-empty-tuples>

  <layout>
    <create-relation class="Action">
      <target>documents.sections</target>
      <action>new:relation:HTML.set:feat:kind("layout")</action>
      <createRelations/>
      <setFeatures/>
    </create-relation>

    <create-tuples class="Action">
      <target>documents.sections.layer:html</target>
      <action>
	section.relations:HTML.new:tuple.(
	set:arg:arg0(target) |
	set:feat:__TYPE(target.@tag)
	)
      </action>
      <createTuples/>
      <setArguments/>
      <setFeatures/>
    </create-tuples>
  </layout>

  <normalizations>
    <map class="FileMapper">
      <target>documents.sections.relations[@kind == "text-bound"].tuples</target>
      <form>@__TYPE</form>
      <targetFeatures>,normalization-feature,normalization-name</targetFeatures>
    </map>

    <relation class="TabularReader">
      <sourceElement>$</sourceElement>
      <lineActions>
	documents.sections.new:relation(tab:column(2)).set:feat:kind("normalization")
      </lineActions>
      <createRelations/>
      <setFeatures/>
    </relation>

    <tuples class="Action">
      <target>documents.sections.relations[@kind == "text-bound"].tuples[@normalization-feature]</target>
      <action>
	nav:features(@normalization-feature) as f.
	target.relation.section.nav:relations(target.@normalization-name).new:tuple.(
	set:arg:entity(target) | set:feat:value(f.@value)
	)
      </action>
      <createTuples/>
      <setArguments/>
      <setFeatures/>
    </tuples>
  </normalizations>

  <type-name>
    <map class="FileMapper">
      <target>documents.sections.relations.tuples</target>
      <form>@__TYPE</form>
      <targetFeatures>,display-type</targetFeatures>
    </map>

    <default class="Action">
      <target>documents.sections.relations.tuples[@display-type == ""]</target>
      <action>set:feat:display-type(@__TYPE)</action>
      <setFeatures/>
    </default>
  </type-name>

  <ids>
    <entities-and-entities class="Action">
      <target>documents.sections</target>
      <action>id:enumerate:tid:T(sort:ival(relations[@kind == "text-bound" or @kind == "layout"].tuples, (if relation.@name == "HTML" then 1 else 1000000) * args:frag0.start))</action>
      <setFeatures/>
    </entities-and-entities>

    <normalizations class="Action">
      <target>documents.sections</target>
      <action>id:enumerate:nid:N(sort:ival(relations[@kind == "normalization"].tuples, args:entity.args:frag0.start))</action>
      <setFeatures/>
    </normalizations>

    <relations class="Action">
      <target>documents.sections</target>
      <action>id:enumerate:rid:R(sort:ival(relations[@kind == "relation"].tuples, args[args:frag0]{0}.args:frag0.start))</action>
      <setFeatures/>
    </relations>
  </ids>

  <write>
    <docs class="TabularExport">
      <corpusFile>docs.txt</corpusFile>
      <lines>documents</lines>
      <columns>@external-id</columns>
    </docs>
    
    <text class="TabularExport">
      <files>documents</files>
      <fileName>"txt/" ^ @external-id ^ ".txt"</fileName>
      <lines>sections</lines>
      <columns>contents</columns>
    </text>

    <layout class="TabularExport">
      <files>documents</files>
      <fileName>"layout/" ^ @external-id ^ ".lay"</fileName>
      <lines>sort:ival(sections.relations:HTML.tuples, args:frag0.start)</lines>
      <columns separator="|">
	@tid|
	@display-type ^ " " ^ str:join:';'(args, start ^ " " ^ end)|
	str:normalizeSpace(str:join:' '(args, @form))
      </columns>
    </layout>

    <entities class="TabularExport">
      <files>documents</files>
      <fileName>"entities/" ^ @external-id ^ ".ent"</fileName>
      <lines>sort:ival(sections.relations[@kind == "text-bound" and not @layout].tuples, args:frag0.start)</lines>
      <columns separator="|">
	@tid|
	@display-type ^ " " ^ str:join:';'(args, start ^ " " ^ end)|
	str:normalizeSpace(str:join:' '(args, @form))
      </columns>
    </entities>

    <normalizations class="TabularExport">
      <files>documents</files>
      <fileName>"normalizations/" ^ @external-id ^ ".norm"</fileName>
      <lines>sort:ival(sections.relations[@kind == "normalization"].tuples, args:entity.args:frag0.start)</lines>
      <columns separator="|">
	@nid|
	relation.@name ^ " Annotation:" ^ args:entity.@tid ^ " Referent:" ^ str:replace(@value, " ", "_")
      </columns>
    </normalizations>

    <relations class="TabularExport">
      <files>documents</files>
      <fileName>"relations/" ^ @external-id ^ ".rel"</fileName>
      <lines>sort:ival(sections.relations[@kind == "relation"].tuples, args[args:frag0]{0}.args:frag0.start)</lines>
      <columns separator="|">
	@rid|
	@display-type ^ " " ^ str:join:' '(nav:arguments, @role ^ ":" ^ @rid ^ @tid)
      </columns>
    </relations>
  </write>
</alvisnlp-plan>
